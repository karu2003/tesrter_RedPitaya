#!/usr/bin/env python3
# PYTHON_ARGCOMPLETE_OK
import os
import argcomplete, argparse, configparser
import re
import logging
import traceback

import signal_helper as sh
import numpy as np
import redpctl as redpctl
import time

###### start: logging ###########
def addLoggingLevel(levelNum, levelName, methodName=None):
    """
    Comprehensively adds a new logging level to the `logging` module and the
    currently configured logging class.

    `levelName` becomes an attribute of the `logging` module with the value
    `levelNum`. `methodName` becomes a convenience method for both `logging`
    itself and the class returned by `logging.getLoggerClass()` (usually just
    `logging.Logger`). If `methodName` is not specified, `levelName.lower()` is
    used.

    To avoid accidental clobberings of existing attributes, this method will
    raise an `AttributeError` if the level name is already an attribute of the
    `logging` module or if the method name is already present

    Example
    -------
    >>> addLoggingLevel('TRACE', logging.DEBUG - 5)
    >>> logging.getLogger(__name__).setLevel("TRACE")
    >>> logging.getLogger(__name__).trace('that worked')
    >>> logging.trace('so did this')
    >>> logging.TRACE
    5

    """
    if not methodName:
        methodName = levelName.lower()

    if hasattr(logging, levelName):
       raise AttributeError('{} already defined in logging module'.format(levelName))
    if hasattr(logging, methodName):
       raise AttributeError('{} already defined in logging module'.format(methodName))
    if hasattr(logging.getLoggerClass(), methodName):
       raise AttributeError('{} already defined in logger class'.format(methodName))

    # This method was inspired by the answers to Stack Overflow post
    # http://stackoverflow.com/q/2183233/2988730, especially
    # http://stackoverflow.com/a/13638084/2988730
    def logForLevel(self, message, *args, **kwargs):
        if self.isEnabledFor(levelNum):
            self._log(levelNum, message, args, **kwargs)
    def logToRoot(message, *args, **kwargs):
        logging.log(levelNum, message, *args, **kwargs)

    logging.addLevelName(levelNum, levelName)
    setattr(logging, levelName, levelNum)
    setattr(logging.getLoggerClass(), methodName, logForLevel)
    setattr(logging, methodName, logToRoot)

addLoggingLevel(logging.WARN  - 5, 'NOTE')
addLoggingLevel(logging.INFO  - 5, 'VERBOSE')
addLoggingLevel(logging.DEBUG - 5, 'TRACE')
try:
    import colorlog
    handler = colorlog.StreamHandler()
    handler.setFormatter(colorlog.ColoredFormatter(
            '%(log_color)s%(message)s',
            log_colors = {
                "TRACE":    "cyan",
                "DEBUG":    "cyan",
                "VERBOSE":  "",
                "INFO":     "",
                "WARNING":  "bold_yellow",
                "ERROR":    "bold_red",
                "CRITICAL": "bold_red",
            }
        )
    )

    log = colorlog.getLogger(__name__)
    log.addHandler(handler)
    log.setLevel('INFO')
except:
    log = logging.getLogger(__name__)
    log.setLevel(level=logging.INFO)
    pass

###### start: utils ###########
def human_size(bytes, units=['','Kb','Mb','Gb','Tb', 'Pb', 'Eb']):
    """ Returns a human readable string representation of bytes """
    if isinstance(bytes, (int, float)):
        return "({:.0f}{})".format(bytes, units[0]) if bytes < 1024 else human_size(bytes / 1024, units[1:])
    else:
        return "(" +str( bytes) + "b)"

def str2bool(str: str):
    if str.lower() in ['true', '1', 'yes', 'on', 'enable', 'enabled']:
        return 1
    if str.lower() in ['false', '0', 'no', 'off', 'disable', 'disabled']:
        return 0
    raise TypeError(f"\"{str}\" should be boolean-like string")

###### end: utils #############

class RedPitayaControl:
    def __init__(self, args, logger):
        self.log = logger
        self.args = args

        self.rp_c = redpctl.RedCtl(dec=32)

#################################################
####### start: setup command line commands ######
setup_argparse_subparsers = []

###### command 'init' ######
def do_init(args):
    redpctl, args = args
    redpctl.rp_c.init()

def setup_argparse_init(cmd_subparser):
    parser = cmd_subparser.add_parser('init', description = 'RedPitaya initialization'
                                      , formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.set_defaults(func=do_init)

    return parser
setup_argparse_subparsers.append({'callback': setup_argparse_init})

###### command 'power' ######
def do_power(args):
    redpctl, args = args
    on_off = str2bool(args.on_off[0])
    redpctl.rp_c.set_power(on_off)

def setup_argparse_power(cmd_subparser):
    parser = cmd_subparser.add_parser('power', description = 'testbed power on/off'
                                      , formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.set_defaults(func=do_power)
    parser.add_argument('on_off', type=str, nargs=1, help='testbed power on/off')

    return parser
setup_argparse_subparsers.append({'callback': setup_argparse_power})

###### command 'generator' ######
def do_generator_power(args):
    redpctl, args = args

    on_off = str2bool(args.on_off[0])
    redpctl.rp_c.gen_on(on_off)

def do_generator_waveform(args):
    redpctl, args = args
    redpctl.rp_c.set_ch(0)

    kwargs = redpctl.rp_c.waveforms.get(args.waveform_type)
    redpctl.rp_c.set_gen(**kwargs)

def setup_argparse_generator(cmd_subparser):
    parser = cmd_subparser.add_parser('generator', aliases = ['gen']
                                      , description = 'RedPitaya generator control'
                                      , formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    subparser = parser.add_subparsers(title='RedPitaya control functions', required=True)
    parser = subparser.add_parser('power', description='Testbed power on/off'
                                  , formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('on_off', type=str, nargs=1, help='on/off')
    parser.set_defaults(func=do_generator_power)

    parser = subparser.add_parser('waveform', description='Generate waveform'
                                  , formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('waveform_type', choices=redpctl.waveform_types
                        , help='Generate predefined waveform')
    parser.set_defaults(func=do_generator_waveform)

    return parser
setup_argparse_subparsers.append({'callback': setup_argparse_generator})

###### command 'relay' ######
def do_relay(args):
    redpctl, args = args
    on_off = str2bool(args.on_off[0])
    redpctl.rp_c.rx_on(on_off)

def setup_argparse_relay(cmd_subparser):
    parser = cmd_subparser.add_parser('relay', description = 'testbed relay on/off'
                                      , formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.set_defaults(func=do_relay)
    parser.add_argument('on_off', type=str, nargs=1, help='testbed relay on/off')

    return parser
setup_argparse_subparsers.append({'callback': setup_argparse_relay})

###### command 'tx-test' ######
def do_tx_test(args):
    redpctl, args = args

    ch = redpctl.rp_c.channels[args.channel]
    redpctl.rp_c.set_dec(128)
    redpctl.rp_c.set_trig(trig_lev=0.065, ch=1)

    print(f"turn channel {args.channel}")
    redpctl.rp_c.set_ch(ch)
    time.sleep(0.1)
    data = redpctl.rp_c.read(counter=1, quantity=16384)
    data = np.array(data)
    real_current = np.real(sh.CQ_330E(voltage=data[1]))
    real_voltage = np.real(sh.voltage_divider_KV(ch, data[0]))

    try:
        rising_edge, falling_edge = sh.x_edge(real_voltage, thresh=30)
        voltage_period = real_voltage[rising_edge[0] : rising_edge[-1]]
        current_period = real_current[rising_edge[0] : rising_edge[-1]]
    except Exception as e:
        print(f"Something went wrong: {e}")
        return

    max_current = np.max(current_period)
    print(f"Max current: {max_current:.2f}")
    max_voltage = np.max(voltage_period)
    min_voltage = np.min(voltage_period)
    peak_to_peak = max_voltage - min_voltage
    num_points = len(voltage_period)
    duration = num_points / redpctl.rp_c.fs
    duration_milliseconds = duration * 1000

    print(f"Duration: {duration_milliseconds} mS")
    print(f"Voltage +-: {max_voltage:.2f} on channel {args.channel} and PP: {peak_to_peak:.2f}")

def setup_argparse_tx_test(cmd_subparser):
    parser = cmd_subparser.add_parser('tx_test'
                                     , description = 'read send evosonar tx and measure it'
                                     , formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.set_defaults(func=do_tx_test)
    parser.add_argument('channel', choices=redpctl.channel_types, help='channel name')

    return parser
setup_argparse_subparsers.append({'callback': setup_argparse_tx_test})

def main():
    
    prog = os.path.splitext(os.path.basename(__file__))[0]
    configs_names = [prog + '.ini']

    config_paths = ['/etc/', '/usr/local/etc/', '/opt/etc/', os.environ['HOME'] + '/.']
    configs = []
    for path in config_paths:
        for config_name in configs_names:
            configs.append(path + config_name)

    # argparse.ArgumentDefaultsHelpFormatter did't work for some reason
    # Added to each help' (default: %(default)s)'
    cmd_parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    cmd_subparser = cmd_parser.add_subparsers(
        title='commands', dest='command', required=True, help='Commands. Add --help to see help'
    )

    config = configparser.ConfigParser()

    defaults = {}
    for config_name in configs:
        if not os.path.exists(config_name):
            continue
        config.read(config_name)
        defaults.update(dict(config.items("defaults")))


    cmd_parser.set_defaults(**defaults)
    for subparser in setup_argparse_subparsers:
        parser = subparser['callback'](cmd_subparser)
        parser.add_argument('-v', '--verbose', action='count', default=0, help='produce more verbose output')
        parser.set_defaults(**defaults)

    argcomplete.autocomplete(parser)
    args = cmd_parser.parse_args() # Overwrite arguments

    if not hasattr(args, 'verbose'):
        args.verbose = 0

    # TODO: add -l, --loglevel flag and config option
    # then code for syncronization --loglevel and --verbose
    # will be meaningful.
    # but now this hack -_-
    args.loglevel_base = logging.NOTE
    args.loglevel = args.loglevel_base
    if args.verbose > 4:
       args.verbose = 4

    # 5 is steps between loglevels
    if args.loglevel > args.loglevel_base and args.verbose == 0:
        args.verbose = int(args.loglevel - args.loglevel_base / 5)

    args.loglevel = args.loglevel_base - args.verbose * 5
    log.setLevel(args.loglevel)
    redpctl = RedPitayaControl(args, logger=log)

    # TODO: move to __init__
    redpctl.loglevel_base = args.loglevel_base

    rc = 0;
    try:
        args.func([redpctl, args])
    except Exception as e:
        if args.verbose:
            log.critical(traceback.format_exc())
        else:
            log.critical(str(e))
        rc = 1

    exit(rc)

if __name__ == "__main__":
    main()
